### 1.1.6. Interception
All __HandlerMapping__ implementations support handler interceptors that are useful when you want to apply specific functionality to certain requests — for example, checking for a principal. Interceptors must implement __HandlerInterceptor__ from the __org.springframework.web.servlet__ package with three methods that should provide enough flexibility to do all kinds of pre-processing and post-processing:

- __preHandle(..)__: Before the actual handler is executed

- __postHandle(..)__: After the handler is executed

- __afterCompletion(..)__: After the complete request has finished

The __preHandle(..)__ method returns a boolean value. You can use this method to break or continue the processing of the execution chain. When this method returns true, the handler execution chain continues. When it returns false, the __DispatcherServlet__ assumes the interceptor itself has taken care of requests (and, for example, rendered an appropriate view) and does not continue executing the other interceptors and the actual handler in the execution chain.
<br/>

See [Interceptors](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-config-interceptors) in the section on MVC configuration for examples of how to configure interceptors. You can also register them directly by using setters on individual __HandlerMapping__ implementations.
<br/>

Note that postHandle is less useful with __@ResponseBody__ and __ResponseEntity__ methods for which the response is written and committed within the __HandlerAdapter__ and before __postHandle__. That means it is too late to make any changes to the response, such as adding an extra header. For such scenarios, you can implement __ResponseBodyAdvice__ and either declare it as an [Controller Advice](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-controller-advice) bean or configure it directly on __RequestMappingHandlerAdapter__.
<br/>